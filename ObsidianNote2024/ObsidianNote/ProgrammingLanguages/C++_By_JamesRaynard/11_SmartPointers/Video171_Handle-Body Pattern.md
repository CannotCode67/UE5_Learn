
In object-oriented programming, we aim to separate a class's interface from its implementation. When a client code uses this class through interface, the client has no idea of what the implementation is. And if changes are made to the implementation, there is no need for client code to change as long as the interface stays the same.

In C++, we use access specifiers to control access to a class. `public` part will become interface, and `private` part will become implementation details. But client can still see the names of the `private` data members, and prototypes of `private`/`protected` member functions, plus the implementations of inline member functions. A little bit of difference between theory and reality.

Client code requires the `#include` to include the class's header file to use this class. Any implementation changes will force a recompile of the client code. So yes, the client doesn't need to change their code, but a recompile is needed. The problem is some applications take hours or even days to recompile. And a real life example would be the weekly maintenance of a server where the server has a couple of hours offline to do a recompile.

The handle body pattern is designed to address this issue. We split the class into two classes, the handle class, and the body class. The handle is an outer class providing the interface to client, and the body class is an inner class the provides the implementation. When a client creates a handle class object, the handle class creates a body class object within. When a client calls a member function on the handle class object, it forwards the call to the body object within. There is another design pattern called adopter describing a class object appears to be something else. Here, the body object appears to be handle object to the client.

The advantage is body class header file is not included by the client. So if we make changes to the implementation, the client doesn't need to recompile. Well, true when the client uses dynamic linking. Most modern applications use dynamic linking anyway, where the program is divided into different parts to be compiled. The core part will become executable object, and others will become shared objects or dynamic linking library. At runtime, the `exe` object will access the `dll` object if it needs to access those codes. If changes are made to that parts that are `dll`, then recompiles of those part doesn't affect the exe file. A real life example of that is hot reload technique. However, if the changes are made to the part that is `exe`, then a recompile will require the application to be offline.
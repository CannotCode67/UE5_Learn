
`unique_ptr` is designed to work with objects living on the heap. The suggested way to create a `unique_ptr` is to use `make_unique()`, where we only need to pass the type and memory allocation is done for us. We also learnt the other way to create a `unique_ptr` is to call the constructor directly and pass a pointer as argument. The second way opens a bigger scope for mistakes, as we can actually pass any pointer, not just pointer with memory address on the heap.

Here we pass a pointer with memory address on the stack.
```
struct destination {}
struct connection {}

connection ToConnect(destination dest) {
	connection conn;
	return conn;
}

void ToDisconnect(connection conn) {
	cout << "Disconnecting" << endl;
}

void Get_Data(const destination& dest) {
	connection conn = connect(dest);
	unique_ptr<connection> ptr(&conn); // pointer to stack
}

int main() {
	destination dest;
	Get_Data(dest);
}
```
When `Get_Data()` returns, function scope is exited and destructors automatically get called for local variables in that scope. The destructor of `unique_ptr` by default calls `delete` on whatever pointer it binds. Calling `delete` on a stack pointer will crash the program.

The `unique_ptr` allows us to provide a custom `deleter`, which is a callable object used to replace the default  `delete` code inside the destructor. When the destructor is called, this `deleter` will be invoked with argument of the bind pointer. Inside this `deleter`, we can apply whatever logics we need to take care of the pointer and the pointed resources.

Here, we use lambda expression to represent our `deleter`, but we should be able to use functor and function pointer as well.
`auto end_connection = [](connection *conn){ToDisconnect(*conn)};`

The constructor can take this `deleter` as second argument, but because the lambda expression has a type generated by compiler, when we pass the type into the constructor, we need to use `decltype()` to extract the type out of the expression.
`unique_ptr<connection, decltype(end_connection) ptr(&conn, end_connection);`

Now the code will look like this, and it will not crash.
```
struct destination {}
struct connection {}

connection ToConnect(destination dest) {
	connection conn;
	return conn;
}

void ToDisconnect(connection conn) {
	cout << "Disconnecting" << endl;
}

auto end_connection = [](connection *conn){ToDisconnect(*conn)};`

void Get_Data(const destination& dest) {
	connection conn = connect(dest);
	unique_ptr<connection, decltype(end_connection) ptr(&conn, end_connection);
}

int main() {
	destination dest;
	Get_Data(dest);
}
```

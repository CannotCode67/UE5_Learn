The original attack logic is partially composed of: raycasting in mouseManager would pass along the game object through events; heroController subscribes to that event and use that info to trigger a coroutine which sets the destination of hero Navmesh agent to that game object; when hero reaches the destination, he performs the attack animation; the attack info exchange method is called by the attack animation event; that method triggers all the related interface functions for the attacked game object. 

The approach above combines target tracking and attack. Now, what we are trying to do here is let all the target tracking be the player's responsibility, and character can perform an attack whenever he wants, but it would trigger info exchange only when there is a target in the range. 

We first enable the left mouse button to trigger the attack animation. When the animation finishes, a info exchange method would be called by the animation event, but now the method is without the attacked game object passed in as the parameter. So, all we get now is animation clips playing but no logic or data exchange. 

About how to retrieve the game object, so far I can think of two ways: Raycasting/Physics.OverlapSphere/Physics.SphereCast or colliders. Raycasting means simulating a ray shooting out and hitting something, and we could retrieve information of the thing we hit. Remember, that thing hitted by the ray need to have a collider/trigger collider for this to work.  Now, this could be ray shooting out from the character, from the screen or whatever makes sense to your choice. And the ray has unlimited distance, but what if we don't want to return something unless that something is what we are looking for. Here we would use layer mask to filter out unrelevant game objects. Lastly, the Physics library also provides other physics simulation to return detected game object's info.  

About the other way, colliders means giving the weapon or projectile a collider, so when they hit something, we will retrieve that game object's info. But this approach normally requires a fix because everytime the FixedUpdate function is called, eveything related to physics like collider and raycast is calculated once. A fast moving object with a collider would miss some of the collisions because the FixedUpdate isn't called when their colliders overlap and their colliders might end the overlapping before the next FixedUpdate is called. Same thing would happen with raycasting if the origin of the raycasting is at a fast moving object, which you wouldn't do for most of the time. 

We should try to implement a collider approach for both melee weapon and projectile, but it is more difficult and takes more resources to calculate, so we save it for later. Now, let's try to implement the raycasting approach first.

![[UnityDevLog/CharacterAttackSystem/GetImage.png]]
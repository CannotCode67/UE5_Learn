Creating simple snow effect with shader. 

The introduction of shader graph in plural sight has a snow shader example using vertex displacement. 

And there is one created by brackey.
![[UnityDevLog/ShaderGraph/GetImage (6).png]]
Below is Brackey's method.
![[UnityDevLog/ShaderGraph/GetImage (7).png]]
Brackey didn't apply vertex displacement. He simply applies color change to achieve snow effect. While the Pluralsight one further applies a vertex displacement to alter the mesh to mimic the snow stacking on top. Both use similar technique. The flow goes like this, first we need a way to determine which area we apply our changes whether the change is color or vertex displacement or both, then we work on the changes. The first part is like obtaining a filter or a mask, like vertex color info, but here we use normal vector instead. The normal vector node returns mesh's normal vector in space we select. Both methods use normal vector node in world space. Vectors use dot product to determine if they are pointing to the same direction. They would get 1 if they are pointing at exactly the same direction. They would get -1 if they are point at exactly the opposite direction. They would get 0 if they are perpendicular. So, since the snow should appear at the top of the mesh, faces with normal vector pointing upward should have snow. Not sure this normal vector is face normal or vertex normal, probably vertex normal, and getting face normal by averaging the vertex normal. The vector3 value of (0, 1, 0) is the direction pointing upward. We use this to do a dot product with normal vector, what we get is normal vector pointing upward resulting 1 (white value), and as normal vector defers from this direction further, its resulting value decreases more. But, we don’t want -1 value, as the black value in a mask is 0, so we clamp the output with a clamp node setting min equaling to 0 and max equaling  to 1. We further use a snow opacity property (slider from 0 to 1) to control the output. Now, the mask is ready. Any change with a multiply node with this output would result in change applying only to the area where normal vector has value greater than 0. 

Because the mask itself is greyscale value, Pluralsight directly add this value to the albedo texture to mimic snow color. Brackey uses gradient noise and simple noise and multiply them together as snow color value to add on top of the albedo map, which offer much more variations. Pluralsight use a normal vector node in object space, multiplying it with a snow depth property to control the magnitude. Then multiply the output with the mask, so only the non black area has change value. Then the output is added together with a position node in object space. I guess this proves normal vector node returns vertex normal vector, that's why it matches the vertex position info outputted by the position node. The sum then outputs to the position slot of the master node. There we have the vertex displacement.
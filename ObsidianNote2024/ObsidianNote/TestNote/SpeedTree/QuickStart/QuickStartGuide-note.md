Left click to rotate the camera, speed tree always uses the origin as the focus point. 

Middle mouse to pan 

Scroll wheel to adjust how close 

Top left window is called generation. It is where we control how to connect different generators to create the foliage we want. Generators are basically templates for parts of foliage. Speed tree provides trunk, leaf, big branch, small branch, and more. Tree is the origin. A example picture below.
![[SpeedTree/QuickStart/QuickStart-images/GetImage.png]]

We add generators by right click and add geometry to the selected. The default one we add uses parameters to decide where to grow and how to grow like a function. We can start with that, and if the result is not desired, we can convert it to hand draw mode to manually add those instances. 

On the right side, we have the window for mesh and material. Normally, the branch or trunk generated by speed tree have geo good enough. The only part we want to define the mesh is the leaf, because it can be the simplest plane or a bit more geo. There are two ways we can get the mesh for our leaf. One is to create it in maya, then import it to Speed tree. Two is to create it  inside speed tree, which is more preferred.  

At the bottom of this window, we can see meshes, materials, and more. The top of this window is to select which material or mesh to preview. The red squared button opens a window to manage different meshes and materials. For meshes, high med low means 3 levels of detail. 

And the … button is for importing meshes from browser.
![[SpeedTree/QuickStart/QuickStart-images/GetImage (1).png]]
![[SpeedTree/QuickStart/QuickStart-images/GetImage (2).png]]

For materials, we can easily import the maps by dragging them into the corresponding slots. If the material is for leaf, we need to tick the two-sided. Going to the cutouts/meshes section, we can define meshes for this material by clicking the add button, then the edit button.
![[SpeedTree/QuickStart/QuickStart-images/GetImage (3).png]]

Here, we can create the mesh based on the texture. Simply left click to create red dot which is vertex, and move them to surround the leaf. The edge is automatically generated based on the vertices. And one more thing is the white dot should be placed in the center bottom of the leaf with its yellow line pointing upward, just like the picture. Speed tree would use this info to decide where to put its pivot and how to align it to y axis. We can only change the yellow line by adjusting the angle parameter in the options section. Once, we are happy with the mesh, we can click the right arrow button to store it for either high or med or low level of detail. The left arrow button would load the stored meshes from its corresponding LOD. We can create the simplest mesh, store it for the low, then adjust the tessellation parameters to increase the geo, then store it in higher LODs. Anchor points can be used to decide where the child would be spawned, but I need to study more to find out how to use it. When we finish with our mesh, we simply click outside of this window, it would be saved and closed. For leaf or flower, we often need to have multiple cutouts(at least three) to generate enough variations so we would not spot they are the same right away.![[SpeedTree/QuickStart/QuickStart-images/GetImage (4).png]]

In the left side right under the generation window, we have the properties window. It is here we control all kinds of parameters of the selected generator. Under the material section of this window, we can assign its mesh and material.
![[SpeedTree/QuickStart/QuickStart-images/GetImage (5).png]]
Gen section contains parameters to control where to spawn the instance, and how many of them. For branch and trunk, we have spine section to control how the spine grow. For leaf and flower, we have orientation section to control which way they face. And forces section, we have control to apply which force to what extent to those instances. To create variation, we can simply randomize the instances, and any child instances would change accordingly, so powerful for procedural generation of foliage. And we can even break the connection between generators in the generation window, modify or create a new generator, reconnect them to instantly get most work done. 

We still have more sections of parameters to control all kinds of different things. Need more time to study all.

Talking about forces, we need to add them to the scene before we can apply it in the properties window. Simply, click forces and add force at the top of the viewport window, we can add all kinds of forces that would help to adjust the facing or placement of the foliage parts. We can also use imported meshes as a force, so the plant would grow around the mesh like ivy on wall. To add imported meshes as a force, simply click and drag the hand button to the scene. And once it is added to the scene, we can adjust its transform, rotation, scale ,etc in the properties window. Remember plant automatically grows around the origin so moving the mesh to or near the origin if we need them to work together.
![[SpeedTree/QuickStart/QuickStart-images/GetImage (6).png]]


Also, we can add vertex color in speed tree. First, we need to select the tree generator and enable the compute vertex color. Then, we can go to each generator to directly set the vertex color or adjusting the value based on its own parent generator. This vertex color info is used for vertex displacement in shader. Think of it as a color ID map for vertex, but it even works with gradient value. Like we can apply vertex displacement to different extents based on the vertex color. But the way we want to utilize this color vertex info also decide how to apply the vertex color as well. Luckily for us, it is easy to do it in speed tree. 

For export, speed tree use a see-what-export-what system. We can press h to hide or unhide the selected generators. Speed tree would only export the shown ones.
![[SpeedTree/QuickStart/QuickStart-images/GetImage (7).png]]

We have export to game and export mesh. With export to game, speed tree would provide a preset for exporting to Unity/Unreal. In this option, speed tree exports the mesh in st file.

![[SpeedTree/QuickStart/QuickStart-images/GetImage (8).png]]

The LOD sections control how many LODs to be contained in the exported st file. Also, the default speed tree colliders are contained in the st file as well. We can toggle the visibility of those colliders in generation window, but they get exported even when they are invisible. But how to generate new collider in speed tree requires more time to study. Speed tree would also perform unit conversion for Unity in st file, but most of the times, we still need to adjust it in Unity's scale factor anyway. And the atlas, none means export without any texture. Non-wrapping means export texture along with st file, but texture would not be compressed to one texture. Like there would be bark texture and leaf texture and the st file. Everything means compress into one texture, and also we need to tick allow V wrapping for it to work properly. 

So, basically, it is not ideal to use export mesh, especially it would not export vertex color. Vertex color info is contained with FBX file. So we want to use export mesh option.

![[SpeedTree/QuickStart/QuickStart-images/GetImage (9).png]]

We need to tick unwrap Uvs to export the fbx file plus the texture. Use stacked instead of unwrapped for each material, so all the material would be compressed into one texture. This way, we get a fbx file for the mesh and the texture. It seems with this way we cannot export with LODs. The workaround is to use the export to game option to get the LODs and the atlas because this way the atlas is good for all LODs. Then use the export mesh to get just the fbx file with vertex color info. Replace the LOD0(highest level of detail) with this vertex color contained fbx mesh. Then, we are good. The further away, the less we can notice the wind effect?

![[SpeedTree/QuickStart/QuickStart-images/GetImage (10).png]]

One thing for the atlas from speed tree is it packs the opacity into the alpha channel of the albedo map. However, the opacity is made to have noise for whatever purpose speed tree intend. However, this would make the mesh semi-transparent in Unity using this opacity map. The fix is using photoShop to open the albedo map, add a black filled background, use the magic wand tool to select the empty pixel, then inverse the selection, add a fill layer with solid white, remember to refine the edge to soften them a bit, then we have a perfectly working opacity map.

How to use speedtree to apply vertex color?
First, by default, speedtree doesn't compute vertex color. We have to select the generators we want, then in the left side window, there is a section called vertex color. And we need to check the option called compute to enable the vertex color functionality. 
![[ObsidianNote/TestNote/SpeedTree/QuickStart/QuickStart-images/GetImage (11).png]]
Now, we can apply the vertex color on each part. There are two styles, one called set, and the other called offset from parent. Set means the value we input is the absolute value. Offset from parent means the value we input is the offset from the value the parent generators have. Also the value here is normalized, so ranging from 0 to 1, not 0 to 256.
![[GetImage (12).png]]
By default, all the vertices controlled by this generator would share the same vertex color. We can use the +/- sign to add variance or we can use the blue chart to specify how to change the vertex color. The chart is a x-y coordinate system. X axis means the parts of geometry, 0 means the part where it is closest to the parent, 1 means the part where it is the farthest from the parent. Y axis means the vertex color value, but in a mapping style. If we set the value to be 0.5, then y =1 means vertex color equals 0.5. And y = 0.5 means vertex color equals 0.25. So, a linear growth line would give us the effect above, the vertex color gradually increases from the root and reaches the value we set in the farthest away geometry.

If a parent generator like twig implements its vertex color in linear growth style, and the child generator like leaf implements its vertex color by choosing offset from parent, then we should know the child vertices are getting different vertex color from their parents based on which part of the twig the leaf is growing upon.

Lastly, the vertex color is included in FBX format only, therefore we have to export the geo as FBX if we intent to use vertex color in unity.


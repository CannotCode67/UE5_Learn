
`TArray<type>`
The data structure above is provided by Unreal, and it is essentially a dynamic array of type that you put in the angle bracket. It's size can expand and shrink as needed. For more information, see the API references.


`FMath::VInterpConstantTo(FVector1, FVector2, deltaTime, interpSpeed)`
API above is static and from the FMath class, and it returns a FVector which is the interpolated result from FVector1 to FVector2 given the deltaTime and speed. It is like Vector3.lerp() in Unity. Also, it needs to be used in Tick() to get the deltaTime to work properly or use `UGameplayStatics::GetWorldDeltaSeconds(this)` to get the deltaTime, but still need to be called in Tick(). Tick() is like Update() in Unity.


`GetWorld()`
API above returns the UWorld object, it is the top level object which is one level higher than a map. The important thing is this object contains many variables and functions useful to us. For example, we can get the time stamp through this object. We can invoke ray cast and geo cast through this object. When we invoke draw debug line, we need to pass the UWorld object as parameter.



```
if (UPhysicsHandleComponent->GetGrabbedComponent())
{
	UPhysicsHandleComponent->GetGrabbedComponent()->WakeAllRigidBodies();
	UPhysicsHandleComponent->ReleaseComponent();
}
```
Code above shows two member functions which we can call when we have grabbed a target actor. The `GetGrabbedComponent()` would return a pointer to the grabbed target, and the `ReleaseComponent()` would simply release the target.


`Cast<UPrimitiveComponent>(Actor->GetRootComponent())`
Code above shows the casting API provided by Unreal, but it is very similar to the `static_cast<targetType>(variable)` and `dynmaic_cast<targetType>(variable)`. We know the `GetRootComponent()` returns the USceneComponent, but UPrimitiveComponent is actually a derived class from USceneComponent. So here we try casting it, if successful, we get a UPrimitiveComponent, if not, we get null.

`CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Cube"))`
API above creates a child object under the parent object, and child object is of UStaticMeshComponent type, and has a name of Cube. This API returns the memory address of the child object.

`UStaticMeshComponent->SetupAttachment(AnotherComponent)`
API above would attach the UStatciMeshComponent to AnotherComponent as child object.


`GetController()`
API above would return the AController object of this actor. Normally, a pawn is designed to be an actor with the capability of being posscessed, thus it would have a controller object. Now, AController class has two one-level-down derived clasess: AAIController and APlayerController. One is used by AI and the other is used by player. They have different functionalities. But how can we get them? All we have is `GetController()`. The `Cast<()` API provided by Unreal is the way we turn our AController into APlayerController or the other. `pPlayerController = Cast<APlayerController>(GetController())`. If it fails, we get a null pointer. We should call this line in `ATank::BeginPlay()`, the equavilent of Start() in Unity, because if we call it in constructor, the controller might not be ready.

`APlayerController->GetHitResultUnderCursor(ECollisionChannel::ECC_Visbility, bTraceComplex, FHitResult)`
API above would fire a ray cast from the camera space where the cursor locates into the level to see if it gets a hit. The first parameter is the channel, if we type `ECollisionChannel::`, visual studio would prompt the possible options to select. `ECC_Visibility` is the trace channel for things we can see. This should be the replacement for finding the trace channel in the config file. The second parameter `bTraceComplex` is a flag to tell the ray cast to use simple collision volume or complex collision volume. If false, use simple collision volume, and vice versa. The complex collision volume is the mesh geo itself. The simple one is automatically generated by Unreal for you.

`FRotator = FVector.Rotation()`
API above would return rotation in FRotator represented by the FVector in world space, meaning using the world origin as the axis origin.

`USceneComponent->SetWorldRotation(FRotator)`
API above would rotate the USceneComponent to match the FRotator, and since the FRotator is in world space, we use this API. The USceneComponent is normally the root component, so the whole actor would turn. This would snap the actor's rotation to FRotator, and if we want a smooth transition, we need the FRotator to be interpolated.

`FMath::RInterpTo(CurrentRotation, TargetRotation, deltaTime, speed)`
API above is desgined to interpolated between rotations. We know the current rotation by calling `USceneComponent->GetComponentRotation()`, for target rotation, we use the `FVector.Rotation()`, and for deltaTime, we use `UGameplayStatics::GetWorldDeltaSeconds(this)`, and lastly, use a float to represent the time to interpolate in seconds.

`Tank = Cast<ATank>(UGameplayStatics::GetPlayerPawn(this, 0))`
API above is a way for other actors to get a reference to the player pawn. The second parameter is the player index, if the game is designed with only one player, then the player pawn should have player index of 0.

`FVector::Dist(GetActorLocation(), Tank->GetActorLocation())`
API above returns the distance between two FVectors.

`UInputComponent->BindAction(TEXT("Fire"), EInputEvent, this, &ATank::Fire)`
API above binds the function `ATank::Fire()` to the mapping called Fire. The second parameter is an enum called EInputEvent, where we can select a value indicating key pressed or key released.

`GetWorldTimerManager().SetTimer(TimerHandle, this, &ATower::CheckFire, FireRate, bLoop)`
Code above shows how we can get a hold of the FTimerManager object through `GetWorldTimerManager()`. Now, this class globally manages timers. And we can set timer with `SetTimer()`. The first parameter is an empty variable of FTimerHandle which will be used to store information about this specific timer, something similar like FHitResult class. Therefore, once we set this timer, we can find it through `FindTimer(TimerHandle)`. The `FireRate` is a float indicating the period of the timer in second. The bLoop is a flag to indicate whether this timer would loop or not. Notice the `ATower::CheckFire()` is a function requiring no input parameter because this version of `SetTimer()` cannot pass value into the pointing function. There is another version of `SetTimer()` which can.

`TSubclassOf<class AProjectile> ProjectileClass`
API above is the way to declare a variable to store a blueprint class in C++. Inside the angle bracket, we see forward declaration, and the class name. We normally create blueprint class derived from C++ class, and this `AProjectile` is a C++ class. Doint it this way, any blueprint class derived from it would be qualified to be stored in this `ProjectileClass` variable.

`GetWorld()->SpawnActor<AProjectile>(ProjectileClass, ProjectileSpawnPoint->GetComponentLocation(), ProjectileSpawnPoint->GetComponentRotation())`
API above is the way to spawn an actor into the level at position and rotation specified. We type the C++ class into the angle bracket, and put UClass in as the first parameter. All blueprint classes are UClass. This is something similar to Instantiate() in Unity.

`UProjectileMovementComponent`
This component is the built-in component provided by Unreal to handle projectile movement. For projectile movement, we can either modify the transform each frame or ask the physics system to do the job, and under the hood, this component is probably going the same route in one of the two options. But by using this component, details are better managed. To add this component into the projectile C++ class.
`ProjectileMovementComponent = CreateDefaultSubobject<UProjectileMovementComponent>(TEXT("Projectile Movement Component")`. Expose it with `UProperty()`, then we can tweak the parameters like max speed and initial speed in the blueprint window.

`UPrimitiveComponent->OnComponentHit.AddDynamic(this, &AProjectile::OnHit)`
The UPrimitiveComponent has a member which is an event called `OnComponentHit`, and given the Collision Enabled for Query and Physics in the Collision Presets in blueprint, this event will be fired whenever this blueprint object hits another object. To subscribe handler function to this event, we use `AddDynamic()` API. Also, we know the handler function has to accept the event arguments as parameters. Here is an example:
```
void AProjectile::OnHit(UPrimitiveComponent *HitComp, AActor *OtherActor, UPrimitiveComponent *OtherComp, FVector NormalImpulse, const FHitResult& Hit)
{}
```
Also we have to add the `UFunction()` macro on top of the handler function to be invoked.

`GetOwner->OnTakeAnyDamage.AddDynamci(this, &UHealthComponent:DamageTaken)`
The actor class has an event called `OnTakeAnyDamage` for taking damage, and we use the same method `AddDynamic()` to subscribe the handler function to this event. The handler function should accept event arguments like: 
```
void UHealthComponent::DamageTaken(AActor* DamageActor, float Damage, const UDamageType* DamageType, class AContrller* Instiagator, AActor* DamageCauser)
{
	Health -= Damage;
};
```

Now, how do we fire the `OnTakeAnyDamage` event? The API provided by Unreal to invoke this event is `UGameplayStatics::ApplyDamage()`. Apparently, we do this in OnHit()
```
void AProjectile::OnHit(UPrimitiveComponent *HitComp, AActor *OtherActor, UPrimitiveComponent *OtherComp, FVector NormalImpulse, const FHitResult& Hit)
{
	auto MyOwnerInstigator = GetOwner()->GetInstigatorController();
	auto DamageTypeClass = UDamageType::StaticClass();
	
	UGameplayStatics::ApplyDamage(OtherActor, Damage, MyOwnerInstigator, this, DamageTypeClass);
}
```
Code above, we see the `GetInstigatorController()` would return the Instigator we need for parameter. However, the code is in Projectile.cpp, so an actor level. The Actor class has a member field of Owner, but unlike component owner being the owner of the component. This owner of the actor is null unless we deliberately assign one. So in the BasePawn.cpp, where we implement the Fire() function, after we spawn the Projectile, we assign the base pawn instance to be the owner through `Projectile->SetOwner(this)`. Without this, the `GetOwner()` in Projectile.cpp would return a nullptr. Another parameter to satisfy is the UdamageType, which allows us to custom damage type. For now, we just use the basic one to satisfy out `ApplyDamage()` function. So `UDamageType::StaticClass()`  would do it. Damage is just a float variable defined in Projectile.h. Now, above three plus the parameters of `OnHit()` function, we have enough info to fill out the `ApplyDamage()` function. And this would then trigger the OnTakeAnyDamage event.


GameMode class in Unreal, GameManager in Unity
There are GameModeBase class and GameMode class built-in by Unreal. GameMode class is derived from GameModeBase class to have more functionalities for multi-player game. To have a custom game mode class, we create a C++ class using one of them as the parent, then create a blueprint class out of our C++ class. In the project setting, assign the blueprint game mode class to the default game mode slot. In the blueprint window of the game mode class, we can set many parameters, and one of them is the default pawn class. Select our ATank class. Now, player start will spawn our tank at the beginning of the game. Also, remember to give the pawn class the player index of 0 in auto possess player section. This would make this pawn class the first choice to possess if multiple pawn classes are there.


`Tank->DisableInput(Tank->GetTankPlayerController())`
API above would disconnect the player input from the pawn action, but we need the controller as parameter.

`Tank->GetTankPlayerController()->bShowMouseCursor = false;`
Controller has a member field called `bShowMouseCursor`, and as its name suggests, it shows or hides the mouse cursor based on its value.

`ToonTankGameMode = Cast<AToonTankGameMode>(UGameplayStatics::GetGameMode(this));`
API above retrieves the pointer to the current game mode object in game mode base type. And we know this is a ToonTankGameMode object, so we cast it to get the access to functionality specific to ToonTankGameMode.

`GetPawn()->EnableInput(this)`
API above shows inside the player controller class or dervied class, we can get its possessed pawn by calling `GetPawn()`. And the pawn class has this `EnableInput()` function to reconnect the player input and the pawn action.

`ToonTankPlayerController = Cast<AToonTankPlayerController>(UGameplayStatics::GetPlayerController(this, 0));`
API above shows we can get the corresponding controller given the player index.

```
float StartDelay = 0.3f;
FTimerHandle PlayerEnableTimerHandle;
FTimerDelegate PlayerEnableTimerDelegate = FTimerDelegate::CreateUObject(
	ToonTankPlayerController,
	&AToonTankPlayerController::SetPlayerEnabledState,
	true
);
GetWorldTimerManager().SetTimer(PlayerEnableTimerHandle,
	PlayerEnableTimerDelegate,
	StartDelay,
	false
);
```
Code above shows another version of `SetTimer()` which can pass a value into the pointing function. And it does that by accepting a FTimerDelegate object. This object is created with the pointing function and the passing parameter values information. That's how it works.

```
UFUNCTION(BlueprintImplementableEvent)
void StartGame();
```
The `UFUNCTION()` macro with the `BlueprintImplementableEvent` specifier would allow the below function `StartGame()` to be implemented in blueprint editor. So we can just declare it in the header file, and invokes it in the cpp file without implementation. This function in C++ simply provides the execution pin to the blueprint when it is invoked. And the implementation logics we make in blueprint would be executed. Here we do this in the C++ ToonTankGameMode class. And the blueprint class derived from ToonTankGameMode class will implement it in the blueprint event graph.

CreateAdvancedAsset->UserInterface->WidgeBlueprint
This WidgeBlueprint is provided to create UI elements and functionality to hook into other blueprint like the `StartGame()` above. It works similar like UI in Unity. We first need the canvas, and then putting UI elements in hierarchy. Inside the event graph, we connect the Event StartGame to a node called Create Widge. Then, select which widge blueprint to create, and connect another node called Added to Viewport. This is how we can utilize the WidgeBlueprint to quickly create UI and bring them into game through blueprint logics. Now the WidgeBlueprint itself can still have blueprint logics just like any other blueprint class. And what we want is a float variable starting in 3, and subtract the delta time until it gets zero, and we use ceil node to round the value to integer. Then, we use a switch statement to catch cases where input is 0, 1, 2, and 3, the other part of the switch statement is the output string. Now, inside the WidgeBlueprint window, the designer section is for designing the UI, and we can turn certain UI elements into variables, so that in event graph section, we can change its value dynamicly. For example, we have a text element displayed in the center of the canvas. And we turn it into a string variable. Now, in the event graph section, we connect the output of the switch statement to a SetText node which is connected by the text variable. When the ToonTankGameMode class creates the widge and brings it to the viewport, it shows the proper text dynamicly. When the number is below 0, we can use a remove from parent node to remove the entire widge blueprint.

```
int32 AToonTankGameMode::GetTargetTowerCount()
{
	TArray<AActor*> Towers;
	UGameplayStatics::GetAllActorsOfClass(this, ATower::StaticClass(), Towers);
	return Towers.Num();
}
```
Code above shows the API to get a TArray of actor pointers of specific class. This specific class has to be UClass, so that blueprint classes are included. We use `ATower::StaticClass()` to get the UClass version of `ATower` C++ class. We also needs to provide the TArray container for the API to write into.

`UGameplayStatics::SpawnEmitterAtLocation(this, HitParticles, GetActorLocation(), GetActorRotation());`
API above shows a way to spawn a UParticleSystem class object at given position and rotation. We call this from Projectile.cpp, when we have a hit.

`UParticleSystemComponent` is different from `UParticleSystem`. For component, it can be added to actor, so as projectile action moves, it follows.

`USoundBase` class
The class above is the class for sound clip.

`UGameplayStatics::PlaySoundAtLocation(this, USoundBase, GetActorLocation())`
API above plays the sound.

`UMatineeCameraShake` class, `UCameraShakeBase` class, and `ClientStartCameraShake(UMatineeCameraShake)`
The class to store the camera shake object and the function to invoke it. The function is an API in controller class.
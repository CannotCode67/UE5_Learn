Finite state machine is one of the method to implement symbolic Ai logics into our character in game, just like behaviour tree. The finite state machine mainly contains the state machine class which is a MonoBehaviour, and concrete state classes. 

Concrete state class derives from an abstract base class, or implement an interface, whichever works, but they are not MonoBehaviours. The abstraction is to set up a set of methods that all concrete state classes need to implement. The most basic version contains Enter(), Update(), Exit(), and we can expand it if needed like add a FixedUpdate(). All theses methods should take a state machine instance as parameter, and return nothing. Enter() should be invoked when this state is entered. Update() should be invoked every frame. Exit() should be invoked when the state is existed. 

The invoking of those methods is the responsibility of state machine. In the Start() of state machine class, we create an instance of each concrete state and hold a reference to them. Next, we have a current state property to reference one of the stored states. Then, at the end of the Start(), we invoke the current state's Enter() function. The next step is just to invoke the current state's Update() in the Update() of state machine class. Whenever we need to switch state, we invoke the switch state method in which we invoke the current state's Exit() function, change the current state, invoke the current state's Enter() function. However, very often the switch state method is called inside the concrete states, and that's one of the reasons why we need to pass the state machine object in as a parameter. Another reason is different concrete states need to access all kinds of information to work, such as Player's position, NavMesh agent component, weapon manager, etc. And it would be messy if concrete states just directly reference them, instead the state machine acts as a central point to all these information, so we reference them in the state machine class. Or some people would rather separate the state machine from the role of infomration access point, by creating an additional class to take on that responsibility. Then, state machine class would just need to hold the reference to that one class. Either way is fine.

Some additional setup to help state machine to work better. One of them is the enum for state ID. And we should add the stateID property in the abstraction so that all conrete states need to implement the getter, not the setter. The enum would have one stateID for each individual concrete state. The benefit for doing this is we can inspect the current state through a self-explain stateID like AttackPlayer or Idle. Otherwise, a reference in string is just not readable to human, and an index of an array requires user to link the number to the concrete state, which is not practical especially when the number of states gets really large.
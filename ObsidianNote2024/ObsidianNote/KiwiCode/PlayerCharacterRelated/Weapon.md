We want to achieve the goal where the player presses the same button, and we get different results based on the weapon equipped. Obviously, the weapon class would have methods to be called by other scripts and the implementations or properties would vary based on different weapons.

Under the weapon class, we write a subclass called Bullet. It is an idea representation but also a container for a bunch of information related to the bullet. Bullet can have its own script if bullet types are some kind of standalone variations. It is a matter of organizing things in a way that makes sense to coder. Here because we put the bullet under weapon as subclass, we might as well write methods to create bullet instances, simulate bullet instances, and destroy bullet instances.

Weapon class normally has a public method called Firing or something similar, so other scripts would get the weapon instance reference and call this method to fire the weapon. It is there we might need to call the create bullet method. Here the StartFiring() method and StopFiring() method is merely controlling the flag called isFiring. And we write a UpdateFiring() method to take care thigns in between. 

UpdateFiring() has logic to control whether we should call FiringBullet() method based on the firing speed of the weapon. Inside FiringBullet(), we check if we have any ammo, if so, we tell the particle game objects to emit. Then, calculate the initial velocity of the bullet, then pass that velocity into the create bullet method. This method also needs the initial position of the bullet, which is a empty game object we roughly place at the end of the gun barrel as part of the prefab. We use a list to store all bullet instances. Also generate weapon recoil by calling the method in Recoil script.

Here we also need to explicitly call the UpdateBullets() method since the UpdateFiring() method only calls the FiringBullet(), which is a place to improve for organizing purpose. UpdateBullets() are called in Update loop, taking in the deltaTime as parameter. Inside, it passes the deltaTime into SimulateBullets() method, and call DestroyBullets() after that. SimulateBullets() calls the GetBulletPosition() method to retreive the bullet position based on bullet's existing time. Then, we run a ray cast between the previous position of the bullet and current position of the bullet to see if we get any hit. Currently if we hit something, we just put a bullet hole particle at the place we hit and set the existing time of the bullet to destroy limit. And SimulateBullets() goes through this whole thing for each bullet instance in the list. Lastly the DestroyBullets() method would just destroy bullet instances based on their existing time.


This script managers many functionalities related to weapon. We basically do all the weapon firing in the Update loop as we need to check the player's input, also in the FixedUpdate loop to simulate the bullet. This part of course is highly related to how we design the weapon script like front end and back end.

Besides firing weapon, we also write weapon equip method. However, the equip method is called by the weapon pickup script. In our example, the only way the character can equip a weapon as from no weapon to holding a weapon is to walk over the weapon pickup object. This pickup object has the script to call the character's equip method passing along the instantiated weapon instance as parameter. The process is invoked through trigger collider.

The character has a rifle as primary weapon and a pistol as secondary weapon. For each weapon, there are three poses, the aiming pose for firing weapon, the holding pose for holding weapon, and the holstering weapon for putting the weapon away. This script is also responsible for the functionality to toggle between poses for each weapon, and toggle between weapons.

The poses are achieved through animation rigging, and thus the script mainly deals with the animation rigging stuff. To use animation rigging, we attach the rig builder component to the top level entity of the character. Then create a empty game object called rig layers one level down, this is for organization purpose. Next, under this rig layers game object, we create game objects that are used to attach animation rigging components, the Rig component to enable this object and its children to be put into the rig builder and the actual constraints achieving rigging effects. The order they are put into the rig builder component is the order for animation rigging to process them. Also we should follow this order to create those constraint objects. And if one constraint object has multiple constraints applied, those constraints are processed from the top to the bottom as well. For example, if there are two IK constraints affecting the hand of the character, the first one would get overridden by the second one. And by changing layer weight, we can shut down the second one's influence, revealing the pose of the first one.

In our example, the character's upper body needs to be able to bend a little based on how high we aim. To do this, we apply multi-aim constraints to character's spine1 joint, spine 2 joint, and head joint. The source object is an empty game object under the main camera, and it is 20 units away at the forward direction.

Next, we do the weapon holding pose. There is a multi-position constraint apply to this weapon pose game object. The source object is the character's shoulder joint, so when the character moves, the weapon pose object would follow the shoulder's movement. Then, we pass this movement through a multi-parent constraint, using the weapon pose object as source object, and constraining a game object called weapon holder. This weapon holder object carries the transform information for the weapon to look correctly. So, at its simplest form, when a weapon is instantiated, it is put under this weapon holder objet and reset the transform to obtain the transform information.

Next, we have the weapon aiming pose. First, we use a multi-position constraint to pass along the shoulder movement to this aim pose object. Then, we apply a multi-aim constraint to aim pose object using the same source object for the upper body bend. This would alter the aim pose object's rotation so that one of its axis would always point to the source target. Lastly, we pass all this information to the weapon holder object again with multi-parent constraint.

Now we have the weapon's position and rotation solved out, we need the character to put the hands at the correct places of the weapon. We use two two-bone IK constraints, one for each hand.  Create two IK hand targets and put them under the weapon holder object, so they stay relative to the weapon's transform. And create two IK hint targets, for now they are just child objects under their constraints objects.

For the weapon holder object, we place it unde the rig layers object so that it is at the same level as the other constraint objects. And, we might want to create one more level under it, an empty game object called weapon pivot. Remember to attach the rig transform component because the IK hand targets are child of this weapon pivot object. The benefit for adding one more level is we can zero out the transform to reset this weapon pivot object like how it works for the anim control and anim group in rigging.

Now the weapon holster pose. In holster pose, the weapon is put away to the place where it rests, and we want the weapon just receives the movement of the body, but no influences from the weapon holdnig pose and weapon aiming pose. Instead of canceling all the weights from previous constraints, we can add two game objects into the upper body bend rig layer. These two game objects are like weapon holder game object, carrying the transform information for the weapon to look correctly when holstered. One is for primary weapon, and the other is for secondary one. Each of them has a multi-parent constraint applied to them, sourcing different joints. We name them primary weapon slot and secondary weapon slot. Now we have the transform information for holstering position ready. We need a switch to tell the weapon change its influencers from weapon holding pose and weapon aiming pose to weapon slot. So we create one last rig layer, creating two  game objects. Each has a multi-parent constraint with two source objects, one is weapon holder, and the other is weapon slot. By altering the weight, we can switch the influencers to suit our need. One important thing to mention is we cannot modify the source objects' weights in runtime through code. The forum says we can only do it in Update loop because animation system collects and evaluates the changes right after Update loop, but it doesn't work for me. That's why in the example, the weight change is achieved through animation clip, which is the recommended way to do it. However, there is still one work around. We can directly change the rig layer's weight through code, and the animation system seems to work with that. So, instead of applying one multi-parent constraint to the weapon pivot, and sourcing multiple objects with weights, we apply one multi-parent constraint to each driving object, using itself as the source object and weapon pivot as the constrainted object. Now, we can change the driving object's rig layer weight to achieve the same result, only this is more tedious, but it works.

Now, we have the infrastructure to create our animation rigging. We can move weapon pose object, weapon aim object, etc. to override whatever original animation clip data. But we actually want to make this a clip itself as well, not just manually move it in play mode. The problem is when the character is humanoid avartar, and recording a clip with animation rigging involved doesn't work. We can convert our character from humanoid to generic avartar, or we give the rig layers object an animator component to play and record the clips involed with animation rigging. Of course we need a new rig controller assigned to this animator as well. Animator can record clips with only the properties of the game object it attaches, and the ones of its child game objects. That's why we usually put the animator on the highest level entity and why we put this second animator on the rig layers game object, so we have all the animation rigging properties at our disposal.

Now, we mention the weapon pickup script calling the equip method on this weapon manager script. The equip method receives the weapon instance as parameter, more specific the weapon script component attached on this weapon instance game object. Inside the equip method, we assign the correct weapon slot, because there are two of them. And, assign the weapon as weapon slot object's child object, then reset the transform of the weapon to make it look correct. The last part is a method called SetActiveWeapon(), which take cares of weapon indexes and pass them into a coroutine called SwitchWeapon(). SwitchWeapon() coroutine basically calls two coroutines in a way where the second one would only start when the first one is finished. The first one is HolsterWeapon(), and if weapon indexes make sense, it sets the animator parameter to trigger the correct holster weapon clip, wait for the clip to finish before return. The second coroutine is ActiveWeapon(). It also checks the weapon indexes and set the animator parameter to trigger the correct draw weapon clip, wait for the clip to finish before return. Those weapon indexes might also cause one of the coroutine to return before doing anything. Like if the character equips a rifle, we only want the character to play the draw rifle clip, effectively skipping the HolsterWeapon() coroutine.

With all these animation rigging infrastructure, animation rigging clips, and coroutines, we can simply check input in Update loop to call SetActiveWeapon() to switch weapons. Pressing 1 would draw the rifle. If the character is in pistol pose, the chracter would play holster pistol clip before playing the draw rifle clip. Pressing 2 would do the same thing except it is for pistol.

There is also one more method called ToggleActiveWeapon(), which we also check for input in Update loop to call. Inside the method, we flip the animator parameter, and based on its value, we either start the ActiveWeapon() coroutine or start the HolsterWeapon() coroutine.

In addition, a public method called GetActiveWeapon() to return the weapon script on the drawed weapon instance. Maybe a property with getter and setter can combine this method with equip method.
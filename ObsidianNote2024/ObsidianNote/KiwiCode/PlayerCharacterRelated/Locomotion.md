The type of locomotion here is strafying with wsad keys and character rotation controlled by the mouse position. And we separate these two functionalities into two scripts. Character locomotion script takes care the strafying and the camera rotate script is for character rotation.

We usually collect input in Update loop because Update loop usually has more frames than FixedUpdate loop. We collect player's input during each Update loop, and if the frame rate is 30 then we do our collection every 1/30 second. But if the frame rate is 15, then our collection is done only every 1/15 second. Higher frame rate means we can catch the player's input in faster speed, leading to a more precise result. But remember no matter how high the frame rate is, there is always chance to miss input.

We gather the input during Update loop, and we actually apply the change in FixedUpdate loop. The reason is Unity calculates Physics in FixedUpdate loop, and by putting the changes in the same loop, we minimize the chance to miss Physics calculation. Why can't we miss that? Well, most of the time, our character has collider component attached for collision detection which is calculated through Physics. Applying changes in FixedUpdate loop would update the collider's position only before Physics engine runs collision detection in the end of the loop. If doing it in Update loop, sometimes, the collider's position is moved to a bad place like inside a wall, which should be prevented if the process is synchronized with Physics calculation.

In Unity, the animator can apply movement through root motion and there is an option called update mode in the animator component allowing us to choose which loop for the animator to update in. The animation, root motion, and animation rigging are all functionalities included by the animator, and get updated during the chosen loop. Update loop with higher frame rate is more friendly to animation, but root motion should be put inside FixedUpdate loop. We can read the animator's root motion properties `private void OnAnimatorMove(){rootMotion += animator.deltaPosition;}` to collect movement changes, and manually apply it in FixedUpdate loop. But I think Unity's current animator component would do this for root motion automatically under the hood, so there might be no need. Which loop is good for animation rigging really depends on the content the animation rigging is involved. If a collider is involved, it is more likely to put it in FixedUpdate, and vice versa.

We use mouse position to control the camera as well as the character rotation. The camera we use is cinemachine virtual camera. To collect the mouse x and y positions, we use cinemachine's axisState as template because this class has more complex properties built in than just position values, such as clamping the value, accelerate time, max speed, etc. It is good for collecting mouse x and y movements on the screen. We use this class's built-in method called Update to update the x and y movements, do it in Update loop as we are collecting input. Then, we apply it to the rotation of a reference object in FixedUpdate loop. What reference object? The cinemachine virtual camera takes in a transform as the target to look at. We add an empty game object under the character's highest level entity, rename it properly, adjust its position to make it nice to look at as third-person style. The camera takes into account of the reference object's rotation, so when we apply rotation to the reference object, it appears the camera is rotating with the reference object as origin. The last step is to adjust the character's rotation so the character always faces the direction as the camera's forward direction. Without this, the character would not turn, just strafying along the world axis. We get the camera's y rotation, apply it with a smooth lerp to the character's rotation. Here we skip a step between changing the reference object's rotation and get the camera's rotation. How do we know the camera would update its own rotation right after we change the reference object's rotation and before we uses this info to adjust our character's rotation? The camera using cinemachine functionality would have a cinemachine brain component attached, and it has a property called update method. The options are FixedUpdate, LateUpdate, SmartUpdate and ManualUpdate. By choosing FixedUpdate, we are effectively telling the camera to update itself based on the reference object in FixedUpdate loop. However, we cannot assure this process would happen right after we update the reference object and before we update the character's rotation. We can test it to see if it happens as we wanted or we can manually update it using ManualUpdate option. And we need to call the cinemachine brain's built-in `ManualUpdate() `method to actually make the process happen. LateUpdate option means the camera updates itself during LateUpdate loop, which is a loop happens after every Update loop. Since camera should move only after eveything moves, so its update process should happen lastly, that's why the LateUpdate. But here obviously we need the process to happen in FixedUpdate loop. The SmartUpdate option means the camera would automatically figure it out which loop to update itself in, LateUpdate or FixedUpdate. Once we turn the character aligned with the camera's forward direction, the reference object's y rotation would become zero in inspector due to the fact now the reference object is facing the same direction as its parent object, the character, does, and a child object's transform is relative to its parent object's transform.
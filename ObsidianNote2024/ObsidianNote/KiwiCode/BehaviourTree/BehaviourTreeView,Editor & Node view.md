We are not building the front end from the scratch, instead, we utilize the framework provided by Unity, but this still helps us to understand the way front end work tremendously. When created, the BehaviourTreeEditor.cs has a couple of functions by default. The class inherits from UnityEditor.EditorWindow class, so that's where the functions come from.

The OpenWindow() method is the method invoked when we mouse click the menu to open the editor. We can define its menu with the attribute `[MenuItem("menu name and path")]`, this would appear on the top menu where the file, edit, assets, and game object. etc locate. The OpenWindow() method would somehow trigger the creation of this root container, I guess.

The CreateGUI() method is invoked after the root container for this whole editor is created. Inside the method, first we store the root container by calling the rootVisualElement property. Then, we get the UXML using `AssetDataBase.LoadAssetAtPath<VisualTreeAsset>("Path")`, call on UXML's CloneTree() method passing the root container as a parameter. Using similar method to get the USS file, but this time, apply the USS file with method on root container like this `root.styleSheets.Add(USS reference)`.  Then the most basic functionality of displaying the editor is finished with UXML and USS applied to the root container.

To further design the editor, we need to use UI builder to modify the XML. The final design of the editor is to divide the editor window into three sections: the tree view section where the graph appears, the inspector section that shows the selected object's properties, and the blackboard section showing the blackboard fields. We use a split view container to divide the whole editor into left part and right part. The right part is for tree view. Then, we use another split view container to divide the left part into top part and bottom part. The inspector view goes to the top part, and blackboard view goss to the bottom part. 

Where do we get the split view? By default, the UI builder provides a standard set of UI elements to add to the XML, but unfortunatly, the split view is not included. We can still add custom UI elements, but for custom UI elements to be manipulated through UI builder, we need to modify it a bit. First, we get the split view implementation by creatign a SplitView.cs class inheriting from UnityEngine.UIElements.TwoPaneSplitView class. That TwoPaneSplitView class defines a view splited into two by a draggable divider, which is exactly what we need. Then, we add `public new class UxmlFactory : UxmlFactory<SplitView, TwoPaneSplitView.UxmlTratis>{}` into the SplitView class. My guess is UI builder knows how to handle UxmlFactory class objects to add to the XML structure, and this line of code would give the SplitView class another identity as an UxmlFactory class. And this UxmlFactory class has an internal name SplitView to link back to the SplitView class, and the characteristics of TwoPaneSplitView class. We would see this modification again when we add our custom inspector view and custom graph view into the editor.

For the xml structure, we have a toolbar on top, and the split view wraps just about anything else. Under the split view, we have the content-contaienr and the dragling-anchor, and we should put our views into the content container. Split view requires two and only two sub UI containers under the content-container. So we add two VisualElement containers under, and rename them `#left-panel`  and `#right-panel`. The # thing seems to be the naming convention for UI container, as the CSS uses the # to begin the name of a selector for containers. A selector is like a style definition targeting a specific type of UI element. Then, the contaienr with a higher position in hierarchy is the  left panel as UI thing works from top to bottom and left to right. Under the container, we add our Label and our view. Label usually locates at the top of bottom part of the container and just text describing the section like inspector so that we know this section is an inspector section. Pictuer below is a capture of the XML structure and the editor preview in the UI builder.
![[UXMLcapture.png]]

Next, we look at the most important view, the tree view, or should we call it the graph view. The BehaviourTreeView.cs is a class inheriting from GraphView class. The GraphView class is under the UnityEditor.Experimental.GraphView namespace. So an absolute reference would be UnityEditor.Experimental.GraphView.GraphView, a bit weird. Anyway, the GraphView class provides functionalities for us to work with graph elements like port and edge, etc. But we also need the UnityEngine.UIElements namesapce for many things, one of which is the UxmlFactory class identity.

We need to define a custom constructor for BehaviourTreeView.cs. In the constructor, we first need to add the grid backgroun to our graph view by insert a gridbackground object into the container. The code is `Insert(0, new GridBackgrounf())`, this Insert() method is a static method from UnityEngine.UIElements.VisualElement class. I am not sure the 0 for index is for what, and whether this grid backgroun object is added to the tree view or its parent container. Anyway, it is oddly enough for a GraphView to not have such a background by default. Next, we add four manipulators using code like this one `this.AddManipulator(new ContentZoomer())`.  The AddManipulator() is from UnityEngine.UIElements, but the constructors are from UnityEditor.Experimental.GraphView. The intergration of different modules is very chaotic. Next, we load and apply the USS file to this as well. The basic constructor is finished here, with the background, the manipulators, and the CSS applied.

One thing to mention is in the BehaviourTreeEdior.cs, we can get a reference to this BehaviourTreeView.cs through this line of code `treeView = root.Q<BehaviourTreeView>()`. I guess Q stands for query, and it returns the first element of this type. We put this lind of code in the CreateGUI() method, after applying USS file. We also get a reference to the inspector view and the blackboard view in the same way.

Another important method in BehaviourTreeView.cs is the PopulateView() method. This is a method we write and it takes a behavour tree object as parameter and generate the graph view. It is called by a method called OnSelectionChange(). And this OnSelectionChange() method is called by Unity whenever the selection is changed. The idea is when the BehaviourTree editor gets opened without any behaviour tree object selected, we should have a empty graph view. Therefore, inside the OnSelectionChange() method, we check if the selection is object of type BehaviourTree, if so we invoke the PopulateView() method. Also we explicitly invoke the OnSelectionChange() method at the end of the CreateGUI() method of the BehaviourTreeEditor.cs. That's because when we select the behaviour tree object then open the behaviour tree editor, we expect the graph view is populated without the need of selecting the behaviour tree object one more time.

Now we know what the method is for, we take a look inside. First, we store the reference of the passed in behaviour tree object. Then, we unsubscribe our custom method `OnGraphViewChanged()` to the event called graphViewChanged, because we are about to delete all the existing graph elements intentionally with `DeleteElements()`. Why do we need to delete them? For the time when we select another behaviour tree object but the editor is showing the graph view of our previously selected behaviour tree object. We need to delete the old graph and create a new one. And as the name suggests, the graphViewChanged event is raised whenever there is a change going on in any of the graph view element. We don't want to react to that since the old graph is irrelevant to us. Right after the deletion, we subscribe again. Next, we check if the passed in tree has a root node. If not, we call on the tree's `CreateNode()` method to create one and assign it to the tree's field. After that, we need to call `EditorUtility.SetDirty(tree)` and `AssetDataBase.SaveAssets()`, since we are creating a scriptable object here and scriptable objects live in asset folder, not game scene. In concept, behaviour tree always has one root node, and the fact that we are checking this in BehaviourTreeView.cs is kind of weird, and proving a point in this example, the creation of a behaviour tree doesn't automatically come with a root node. Next, we iterate through the tree's list of nodes to call the CreateNodeView() method on each node. This method would create a graphical representation of the node, we call it node view. We then iterate through the tree's list of nodes again, this time we nest a loop to iterate through the current node's child or children, then create a graph edge between the graphical representation of the parent node and that of the child node. Lastly, we pass the graph edge into the `AddElement(edge)` method. This would add the edge to the graph and raise the graphViewChanged event. Edge here is the connection between two node, representing the parent-child relationship between the nodes. That's the end of PopulateView().
![[bTreeView.cs-codeSnippet01.png]]

As some of the methods above need more details on implementation, we roughly know what they are for. We would go into those implementations, but now we have to deal with this node view thing to make our understanding go smoothly.

The NodeView.cs class inherits UnityEditor.Experimental.GraphView.Node class. So under the UnityEditorExperimental.GraphView namespace, we have GraphView class the BehaviourTreeView inherits from, and the Node class the NodeView inherits also. By inheritance, the NodeView class provides containers for ports which the edge connects to. And it comes with a default Uxml structure and USS file, which we override with our own. In one of its constructors, we can provide the path to our uxml file to tell it to use our uxml file to represent the NodeView in editor. It looks like this `public NodeView(Node node) : base("Assets/MyBtree/NodeView.uxml")`. Inside the constructor, we store the reference to the passed in node object. Assign the name of the node object to the title field, assign the node object's guid to the viewDataKey field. Use the node object's graphPosition to setup the node view position on graph `style.left = node.graphPosition.x` and `style.top = node.graphPosition.y`. The next step is to Invoke CreateInputPorts() and CreateOutputPorts() methods. The node view has two fields of type Port, one is input and the other is output. Port is another class under the UnityEditor.Experimental.GraphView namespace. Both methods are similar, creating port object based on the node type and assign it to the field. Port is created using `input = InstantiatePort(Orientation.Vertical, Direction.Input, Port.Capacity.Single, typeof(bool))`. The InstantiatePort() method comes from the Node class. Lastly, we need to add the input Port objects into the inputContainer, and output Port object into the outputContainer, so that they are properly displayed. Both are properties of Node class. Next we invoke method `SetUpClasses()`. Inside this class, we check what type this node is, and add a corresponding label to the node view object with `AddToClassList("action")`. I know the method name called class list, but this thing works as a label for the CSS selector to target at, so that different node types would have node view objects with different colors. It has nothing to do with our C# understanding of class. That's the most part of the constructor. 

There are also two override methods in NodeView.cs which are invoked by Unity. One is SetPosition() and the other is OnSelected(). The SetPosition() method is invoked when we move our node view in graph. And the OnSelected() method is invoked when the node view is selected. The reason why we override these two methods is we want to add some logics when they are invoked, so we still need to invoke the base version of them like this `base.SetPosition(newPos)` and `base.OnSelected()`. By default, the base logics in SetPosition would take care of setting the node view's new position. We retreive the new position and store it in the node object, so next time the node is passed into the CreateNodeView() method, we get a node view appears on the last position as if it remembers where it locates. The SetPosition has a parameter of type Rect, which we get the new x and y position of the node view by accessing the Rect object's xMin field and yMin field. Why not a Vector2? I don't know. Codes look like this: `node.graphPosition.x = newPos.xMin` and `node.graphPosition.y = newPos.yMin`. After we modify the node, which is a scriptable object, we call `EditorUtility.SetDirty(ndoe)`, which helps preventing it from reverting to previous state after an assembly reload. For OnSelected(), we have a public `Action<NodeView>` field called OnNodeSelected, and we invoke it passing this object after we check there is listener for this event. The BehaviourTreeView.cs registers this event inside its CreateNodeView() method with another `Action<NodeView>` OnNodeSelected. Basically, the BehaviourTreeView is just passing this information up. The BehaviourTreeEditor.cs subscribes to this event and invoke a function to pass this NodeView object into the InspectorView.cs, where it does some work to show all kinds of properties of the NodeView object in the inspector section.

There we have the most part of the NodeView class: a constructor to prepare the uxml file, create the ports, and setup selector targets; a function to take care moving the node view, and a function to take care the selection of the node view.

The creation and deletion of the node view is handled in the BehaviourTreeView.cs. As node view is a graph element, we need to call the AddElement() method passing in the node view object like we do for edge. So, when we perform a creation of a node in the editor, we expect it to truly create a node scriptable object and a node view representing this node would appear on the graph. The code goes like picture below.![[bTreeView.cs-codeSnippet02.png]]
Another situation is when we invoke PopulateView(), CreateNodeView() is called for each existing node object in the tree, where CreateNode() is not involved.

Okay, that's the creation. The deletion process is we select the node view, press delete key and both the node view and the node scriptable object would be gone. When we press delete on a graph element, the GraphView which BehaviourTreeView inherits from would take care of this. But we can still ride along to apply some additional logics in the graphViewChanged event. We subscribe to this event with our custom OnGrahphViewChanged method. And we know a listener method have to take in the event information as parameter, in this case, it's a built-in class called GraphViewChange. This GraphViewChange class contains the changes made to the graph that raise the event. So every time the event is raised for some changes happen, this object contains those changes. We check if this object contains change we care like a node view to be removed, if so we access this node view to get the node object reference, pass it into the tree's DeleteNode() method to delete the node scriptable object. 

When we create a edge, we want the two related node scriptable objects to form a parent-child relationship. And upon deletion of a edge, we want this referencing to be gone. Using the same listener function to ride along, we can add those logics as well.
![[bTreeView.cs-codeSnippet03.png]]

The creation of an edge involes the mouse clicking and dragging, and deletion involves the delete key. They are generic enough so that the GraphView class already handles those user input. However, right click to open a menu and click one of those options to create corresponding node view, which we have to define by ourselves.

The right clicking menu is called contextual menu, and there is a method in the GraphView called BuildContextualMenu() handling this. It is a listener method subscribing to the event of user right click input. The default version creates a menu of copy, paste, cut, etc. If we don't want it, we can comment out the invoking of base version when overriding the method. The contextual menu we want is when we open the menu, we see the node view name and its node type. So, the way we do it is to get all the System.Type that are derived from the type of ActionNode. So far there is only DebugLogNode, but when we have multiple concrete nodes derived from ActionNode, we can loop through this collection of types to add a option in the contextual menu for each one of them. We do this for CompositeNode and DecoratorNode as well. The event parameter has a menu property makes me guess each time we right click, the contextual menu is created on the fly. In the menu's AppendAction method, we provide the string for display and the function we want to invoke.
![[bTreeView.cs-codeSnippet04.png]]
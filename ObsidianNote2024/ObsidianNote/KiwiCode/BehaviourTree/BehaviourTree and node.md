There are multiple C# files containing the word BehaviourTree. We first have this BehaviourTree.cs file containing the tree's logics. The BehaviourTreeEditor.cs contains the logics for this entire editor window. And the BehaviourTreeView.cs file contains the logics for the graph section of the editor. There is also BehaviourTreeManager.cs file attached to game object to actually utilize the behaviour tree scriptable object. Yes, this BehaviourTree.cs class inherits from the ScriptableObject class.

The tree has a list of nodes to reference all the nodes, and a root node to call its update function every frame. Of course, we wrap this with a tree's own update function and it is called by the BehaviourTreeManager which is a monobehaviour.

Node is what the tree is made of. First of all, Node.cs is an abstract class inheriting from ScriptableObject. It contains an enum of three states: running, success, and failure. It has a update function returning a state. Inside this update function, we use a flag to call OnStart() once, call OnUpdate() everytime, and call OnStop() once the state return by OnUpdate() is State.Failure or State.Success. We effectively smash Enter(), Update(), and Exit() all into this update function. Those OnStart(), OnUpdate(), and OnStop() are abstract methods waiting to be overwritten by the concrete node class, and only OnUpdate() returns a State, while the other two return nothing.

There are four categories of nodes, so we have one more abstract layer before getting to the actual node class. Four main types of nodes are root node, decorator node, composite node, and action node. Root node is the starting point of the tree, has no parent node and one child node. Decorator node manipulates the State return by its child node, and it only has one. Composite node works like switch statement or for loop, controlling the flows. and it can have more than one child node. Action node is the end point of the tree, defining the actual action performed by the game object, and it has no child node, only parent node. By the way, all nodes except for root node have only one parent node. We create four more abstract classes for these four types of node. All of them inherits from the Node class we write, and we add the property to store the reference of their children or child.

Finally, we create the concrete node class inheriting from one of those four abstract node classes. One created is the DebugLog node. And because the concrete node classes are no longer abstract classes, so we have to implement those three abstract methods. For DebugLog class, we put Debug.Log() in one or all of those methods, so when this node is entered, updated, and exited, we all get debug logging in the console window. Don't forget the return type of OnUpdate() is State, and because Debug.log() always works, so we return State.Success after logging. DebugLog node is action node.

Now, we have one Decorator node, the Repeat node, which is even simpler. Just call on its child node's update function and return State.Running no matter what state the child is returning. Becuase the tree would keep on calling update on root node if the return state from root node is Running. Where the root node's return state comes from? It goes down to the tree and the first node returning one of those three states would pass the return state all the way to the top. And if it is State.Running, the tree calls root node's update function and execution goes down again. Therefore, the Repeat node returns State.Running would get the tree running all the time, while the child of repeat node executes its logics again and again. To make the repeat node more useful, we normally gives the repeat node a property to control how many times it should repeat.

Lastly, the sequencer node. It is a composite node. It has an int property to be used as a index to loop through its children to call update function on them. If one of its child return failure, this node return failure. If the indexer gets to the number of its children, it returns success.

Now we have one for each type of node, and if we use them to build our tree without the graph editor, we can do it. The way to do it is inside the BehaviourTreeManager class, in the Start() function, we instantiate the tree, and the nodes we want, using ScriptableObject.CreateInstance<>(), because they are scirptable objects. We then assign nodes to other nodes in child or children properties, starting from the bottom of the tree, and work our way up. When we are done, we assign the root node to the root node property of the tree. In Update loop, we call the tree's update function. As the tree gets bigger and bigger, we have a massive Start() function, which is actually not too bad, because building a bug free graph editor for behaviour tree is not exactly easy. But from this point, we begin our way trying to build one.

Before doing that, we have one more common practice for behaviour tree to mention. Often, we have a container called blackboard to store a bunch of variables for nodes to read and write on, so that information can be exchanged between nodes. We have a Blackboard.cs inheriting from nothing, inside the class, we just define properties the nodes need. In BehaviourTree.cs, we have a blackboard property and by default creating an empty instance assigned. For the nodes to be able to access it, we either give a tree reference to all nodes or a blackboard reference, doesn't matter. In this case, we give all the nodes a blackboard reference. Ideally, the blackboard has a dictionary structure to store those properties, with each one having a unique key.



------------------------------------------------------------------------
The later update

go read the scriptable object note.
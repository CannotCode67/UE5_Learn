The reason why we exclusively talk about scriptable object is in later update Kiwi coder actually writes a SerializedBehaviourTree.cs to work with BehaviourTree.cs and Node.cs. This SerializedBehaviourTree.cs class inherits from nothing, but its constructor is to load in a behaviour tree scriptable object and pass it to the constructor of a serialized object and hold a reference to that object. It seems scriptable object is designed to be modified through the editor, and any modification through the editor can be properly handled. However, if we change it through code, we should use the classes of SerializedObject and SerializedProperty to do it. Why? Because the scriptable object lives in asset folder, and Unity has implemented a set of mechanism to save the change or undo the change or redo the change, etc. for objects in asset folder. To utilize those features, the SerializedObject class provides APIs which are hooked into those systems underneath. If we directly modify a scriptable object, then we need to manually invoke the correct APIs at correct places to properly expose our change to those systems, which requires the understanding of those systems. For example, we see the code `EditorUtility.SetDirty()` at several places, this code would turn the parameter object's change into something the Scene save() opertion can detect, and hook the change into Undo/Redo system, etc. That's why we see Kiwi coder mentions without this line of code, the changes get lost after a re-assembly reload because the system doesn't hold on to that change somewhere. However, this line of code is just one part of the system, and Unity recommends us to use the SerializedObject class to automate those processes.

The way to do it is first to create a SerializedObject passing in the scriptable object like this: `serializedObject = new SerializedObject(tree)`. Then, we use SerializedObject's FineProperty() and FindPropertyRelative() methods to obtiain the field, but those methods return not the field itself, but a SerializedProperty object of the field. And we access the SerializedProperty object's property to obtain the field value. This SerializedProperty class is like GraphViewChange class, it has many properties to store different kinds of possible field values. For example, if the field is a int value of 112, then we need to access the serializedProperty.intValue to get 112. After we modify the fields we need, we invoke the SerializedObject's ApplyModifiedProperties() or the variant of this methods to save the changes. In this way, the change is properly handled. You may wonder, we are changing a SerializedObject instance and a SerializedProperty instance, and that changes our scriptable objects? My guess is conceptually those two classes work as a temporary container for modifications, and once we call on the ApplyModifiedProperties() or something alike, the container would sync those changes to its target object. And all the systems for object editing are hooked into these two classes, so we get all the benefits by working with them. If we don't commit the change, we don't need to worry about the reverting the real object back because they are never touched at the beginning. We can simply get rid of the change inside the SerializedObject instance, or get rid of the SerializedObject instance entirely if we want.
AiCharacterStats class manages stats for Ai character. It is very common but here we focus on how it derives from the base class CharacterStats as a subclass. The CharacterStats is a MonoBehaviour, so it has a implemented Start() and a BeGone(), in addition, we have a TakeDamage() method invoked by Weapon class. So far, it is simple. The way to make a subclass is to add one virtual method into each of them. OnStart(). OnDeath(), OnTakeDamage(). Then, the AiCharacterStats class inherits from CharacterStats class, and overrides those three methods to implement logics specific to ai character. And PlayerCharacterStats class can do the same thing, but this time for player character. Doing it this way, the base class CharacterStats implements logics appropriate for all characters, and those logics would get executed even on a derived class. On top of that, the character specific logics would get executed as well.

Another way to do it is just give the virtual keyword to the methods in CharacterStats. You may wonder CharacterStats gets Start() and Update() from MonoBehaviour right? Can we add virtual in front of them? However, MonoBehaviour doesn't implement those methods. Unity finds those implemented Start() and Update() alike methods by reflection. They are not a bunch of virtual empty methods being called. So, basically, we are defining the Start() method, then we of course can put a virtual keyword in front. Just inheriting from MonoBehaviour would tell Unity that this Start() method needs to be treated as the game loop Start() function. Back to our topic, we put the virtual keyword to the methods in CharacterStats, and in AiCharacterStats, we override the method to add ai logics and explicitly tell the base class to fire the same function, `base.Start()` to execute the common logics.
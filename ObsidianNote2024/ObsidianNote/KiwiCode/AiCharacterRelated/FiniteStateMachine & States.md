We already have a note dedicating to the concepts of a finite state machine, so here we are not focusing on the structure of a FSM, instead we take a look at the context of FSM in our case of ai character, to see how the FSM is integrated into our ai character.

So far in our example, we have Idle state, FindWeapon state, ChasePlayer state, and AttackPlayer state. We begin with the simplest one, the Idle state. The ai character in this Idle state seems just standing there, but it is not doing nothing. It is checking conditions to see if it should transit to other states. I mean if we just need a character to stand there all the time, then why bother creating a whole FSM to do so, right? So, in its Update(), we check if the player is within our detecting distance, if so we further check if the player is in front of the ai character. If still true, then we transit to FindWeapon state. Why FindWeapon state, but not ChasePlayer state or AttackPlayer state? Well, the ai character by defualt doesn't have a weapon to begin with. But this is rather a design problem than a programming problem. In some design, ai character's default state is FindWeapon state, skipping the Idle state. And so far, there is no way for ai character to enter idle state besides setting it as the default. But, again, we can change that if the design requires. A more thing to add, we should lower the cost by giving it some simple condition to check like if the player character is dead, then we should not run the more complex check codes.
![[FSM-codeSnippet01.png]]

The next state becomes more interesting, the FindWeapon state. In this state, the ai character sets off to find weapons. Again, if our design needs the ai character to have a weapon by default, or can only equip one weapon, then probably this state can be skipped. There are two ways of finding weapons. One is to get all the weapin pickup using FindObjectsOfType<>(), and plan a path to the closest one. The other is to tell the ai character to walk to random positions, and if the sensor detects the weapon pickup, only then it would plan a path to that weapon pickup. We will go into the details of the whole sensor things later. For now, just understand it as what we perceive as sensor in real world.

Let's examine the first approach now. In the Enter(), we get a list of weapon pick up and find the closest one, then set the destination of nav mesh agent to that location. Great place to put those methods since they both are expensive calls, we just do it once. Before the ai character gets there, the weapon pickup might moves to other places in some design, or in our design, it might be taken by other ai characters or the player. So inside Update(), we should check if the nav mesh agent's path is finished using code like this: `stateMachine.navMeshAgent.pathStatus != UnityEngine.AI.NavMeshPathStatus.PathPartial`. The NavMeshPathStatus is an enum containing three values ued to denote if a path is in a state of finish, start, or in the middle. If the path is finished, meaning we get to the place where the closest weapon pickup was. We further check our weapon dictionary's Count property. If it is equal to zero, then we still have no weapon, and we should modify the list of weapon pickup we got in the Enter(), by getting rid of the null one like this `pickups.Where(p => p.gameObject != null)`, then find the cloest one in the new list, and set it as our new destination. If the weapon dictionary Count property is equal to one, meaning we get one weapon. We can transit to ChasePlayer state if that is our design. But here our design is to get both types of weapons equipped before chasing the player. So in that case, we first get a WeaponID by checking the weapon dictionary's existing key, if the key is WeaponID.machineGun then we get WeaponID.handGun, and vice versa. Next, we modify the weapon pickup list by keeping all the elements with weaponID equalling to our weaponID variable. Modify the list once again to get rid of the null one. Then we get the closest one in the new list and set that as destination.

Now, remember we said there is another way? The second approach would just tell the ai character to go to random places and if detects a weapon pickup, we go pick it up. When we have one weapon, we check if any new detection is weapon pickup of another weapon type, if so, we go pick that up as well.

Inside the Update(), we can check if the weapon dictionary Count is equal to 2, then we transit to ChasePlayer state. Or we can invoke the transition in the SwitchWeaponAnim() coroutine of the ai weapon manager class because if we find the weapon, we are definitely calling the EquipWeapon() method. However, is it a good idea to switch state outside the states class? It seems this makes it more difficult to track the logics. For this particular reason, we look at the next state, the Death state.

The Death state is simple, we put eveything in Enter(). We disable the weaponIK, tell ragdoll manager to activate ragdoll, disable the healthbar, drop the weapon, etc. The insteresting point here is the only way the ai character can get into this state is through the code in AiStats class. None of the state is checking if the ai character's health drops to or below zero. If we put the health check in all the states, then our Update() would need to check this condition all the time, very inefficient. The way we do it, the bullet hit would call the TakeDamage() method, and inside this method, we check the condition. So it is checked only when necessary. The point here is sometimes, it seems taking the switch state logics outside of the states classes is the right thing to do.

Now ChasePlayer state. In our example, after we implement the sensor system, when the ai character obtains two weapons, it skips this state and goes straight to the AttackPlayer state. You may wonder, how does the ai character know where the player is. Obtaining this information is very similar to obtaining weapon pickup locations. Either we cheat getting this information through reference to the object, or we use the sensor system to detect objects. And we are using the first approach for player's position in our example, that's why the ai character goes straight into the AttackPlayer because it knows where player is. And inside the AttackPlayer state, we still tell the ai character to use player's position as destination, but we increase the stopping distance so that ai character would not go all the way into the face of the player while it's attacking. If we use the sensor system approach, the ai character would need to walk randomly and if detecting player object, then it enters the AttackPlayer state, and this state of finding player doesn't really suit the name ChasePlayer, it should be named FindPlayer really.

Nonetheless, we discuss what a ChasePlayer state should do. Chasing the player means we know where the player is. We can then assign the player's position to the nav mesh agent's destination during the Enter(). Because the player can move, so we have to repeat this code somehow in the Update(). It is an expensive call, better we check a couple of things before reassigning the destination. First, we use a timer technique to limit the frequency, and only when timer is below zero, we check how far away from the player's current position to the nav mesh agent's destination, a.k.a the player's previous position. If it is smaller than a limit we set, then we consider the player is still around the destination, so we don't reassign it. Otherwise, we reassign. And in the end, we reset the timer. We can also check if the distance between the player's position and the ai character's position is smaller than a range we set, then we can assign the player transform into the weaponIK target transform to activate the aiming. We want to do this because the ai character should aim before fire, not simultaneously. Then, if the distance is even smaller than a fire range we set, we switch to AttackPlayer state. But here, we have three numbers to manage, the stopping distance, the aim range, and the fire range. To fine tune them so that the numbers work well together is not easy.

Finally, the AttackPlayer state. If our design doesn't force the ai character to find two weapons before attacking the player, then in the FindWeapon state, when we detect the player through the sensor system, and we have one weapon, we can jump to AttackPlayer state, which makes more sense. But again, this is a design choice, not a programming problem. If we enter this state from the ChasePlayer state above, then we are ready to fire since the player is in the fire range. We implement the firing in the Update() because the ai character can fire multiple times. In Update(), we first call a method named SelectWeapon(), in which we call the ChooseWeapon() method returning a weaponID, and check if the weaponID is the same as the current weapon, if not, we invoke the SwitchWeapon() in ai weapon manager class passing in the weaponID. The ChooseWeapon() should contain the logics to decide which weapon is better based on the current situation. This separates the thinking logics and the doing logics, which is nice and clean. After the SelectWeapon(), we get to the ReloadWeapon(). In this method, we check if the current weapoon's ammoCount is smaller or equal to zero, if so, we call the ReloadWeapon() method in the ai weapon manager class. After the ReloadWeapon() in AttackPlayer state, we call FiringWeapon() in ai weapon manager class passing the player transform as target. Then we check if the player is dead by checking the gone property in PlayerStats class, if so we set the weaponIK's target transform to null, call the navMeshAgent's ResetPath() to clean the path, and invoke the PutAwayWeapon() function in ai weapon manager class. A better approach here might be using event instead of checking PlayerStats every frame. Also, we need to update the bullets, we invoke the UpdateFiring() method in ai weapon manager class in FixedUpdate(), which would be invoked by the real Unity FixedUpdate() in the ai state machine class. Now, if our player manages to run out of the fire range without dying, the ai character would be stuck at where he is. So we add some more checks in Update(), checking if the distance between itself and the player is outside the range. If so, we set the weaponIK target transform to null, and switch to ChasePlayer state. This would close the loop, so the ai character would chase the player again until it is close enough then enter AttackPlayer state again.

That's all the states now. But we are not done. Remember that sensor system we keep mentioning? It is the time for us to go there. The reason I put the sensor system here because the sensor system is integrated mainly to work with the FSM. It is barely used outside of the state machine. The sensor system contains three parts: the ai sensor class (MonoBehaviour), the ai sensor memory class (inherits from nothing), and the ai sensor target class (MonoBehaviour).

---------turns out the sensor system contains too much details to jam into this note, go to sensor system note for more
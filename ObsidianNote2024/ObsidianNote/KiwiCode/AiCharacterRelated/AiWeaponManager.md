Ai character can equip weapon and fire weapon as player character does. The ideal scenario is all the codes and structure are the same for both characters, just the input portion is different. Player character's input comes from the input system, and ai character's input comes from ai engine like FSM and behaviour tree, etc. However, in our current example, we only have the weapon using the same script, and above that level, the codes are much different. Maybe we can optimize our codes and structure towards the ideal goal in future.

For the player, the weapon pickup class tries to find its collided object's weapon manager script. If it finds one, it then instantiates the weaponPrefab and passes the weapon instance into the weapon manager's EquipWeapon() method. Unfortunately, ai character doesn't have a weapon manager script. It has an ai weapon manager script. So, inside the weapon pickup script, we also try to find the ai weapon manager script on collided object. If finding one, we don't pass a instance directly, as the `Instantiate()` method is expensive. The process of instantiating a weapon, then passing it to manager, only to find out manager cannot equip it, then destroying the instance, is not efficient. So instead we pass the reference to weaponPrefab into the ai weapon manager's EquipWeapn() method.

AiWeaponManager class is a big one managing the functionalities of weapon equip, weapon reload, weapon switch, weapon firing, and weapon aiming. We start from weapon equip. Inside the EquipWeapon() method, we start with checking if there is any weapon. If none, we instantiate the weaponPrefab, stores the weapon instance to a dictionary using the weapon's field called weaponId as the key. We swap the animator cotroller with the weapon's anim controller. In design, ai character has two slots for weapons, but each slot is fixed for its corresponding type of weapon. So one slot for machine gun, and the other is for hand gun. Running into a new machine gun pickup would do nothing if there is one already in the slot, and it would not fill up the hand gun slot even it is empty. That's why we use dictionary to store weapons, since the key being the weapon type is unique. The machine gun prefab comes with a default anim controller having clips specific for machine gun. The hand gun prefab comes with a override anim controller which allows us to assign different clips but using the same anim states structure as the default one. That's why we need to swap the anim controller, so the clips under anim states are replaced with the proper ones. Next, we need to tell the weapon to attach something before the ai character plays the draw weapon animation. In the clip, the ai character reaches the weapon and draws it, but for different weapons, it reaches different spots. Like hand gun is at the thigh, and machine gun is at the back. There is a mesh socket manager class having a method called Attach(), which put the weapon transform under the correct joint based on its enum called socketID. So we check if the weaponId is hand gun or not, if so we return the socketID.RightLeg, otherwise, return socketID.Spine. The mesh socket manager holds a dictionary where the socketID is the key, and mesh socket object is the value. Two mesh socket scripts are attached to two child empty game objects. The code is like this.
![[aiWeapon-codeSnippet01.png]]
Alternatively, we can use animation rigging for this. However, the weapon aiming is a custom aim IK which doesn't work with animation rigging since there is a problem about the order of effect. If we use animation rigging, we need to use it for all IK stuff. Then we can define the order of effect in the rig builder. Otherwise, Unity just randomly mixes the order and the whole thing doesn't work.

We are miles away from the topic. So we have the correct socketID, and attach the weapon to the right location, play the proper draw weapon clip. Now what? We don't directly tell the animator to play the clip, we start a coroutine, as we still have a few things to set up after the clip is finished playing. In the DrawWeaponAnim() coroutine, we set the animator parameter to trigger the clip, tell the execution to wait for 0.3 seconds using `yield return new WaitForSeconds(0.3f)`, because that's the time guranteed the transition from ilde state to draw weapon state is finished in our example. We can set it to an even shorter time in animator, and the execution can wait for a shorter time. Then, we check the animator's current anim state's normalized time, if it is smaller than 1.0f, meaning it is not finished, we wait until it is finished. Then, the next line of code is executed only after the animation is finished playing. We get a bool flag's value from animator's parameter. This bool flag called weaponDrawed is used in conjunction with current weapon to enable or disable weapon firing and weapon reloading. Lastly, we pass the current weapon's hotspot field to the weaponIK's aim transform. Weapon aiming is enabled only when aim transform and target transform are assigned in the weaponIK script. 
![[aiWeapon-codeSnippet02.png]]
Till here, we finish the case when we have no weapon before the EquipWeapon() is invoked. Now we check other cases, but with the first one down, we can understand the code much better now. If current weapon is not equal to null, meaning we have a weapon already, then we want to check if this weapon is of the same type as the one we are currently holding by asking if the dictionary contains the key matching the weaponPrefab.weaponId. If true, then we already has one of this type, we do nothing by return. If false, meaning the incoming weapon is of a type which we haven't had. In design, we want to equip the weapon and switch to it. So, same process here, we instantiate the weapon, add it to the dictionary, attach it to the right place based on socketID, and in the end, we call for another coroutine. Probably should put the same drill in a method. This time, the coroutine is called SwitchWeaponAnim(), because we already hold a weapon, so we need to put away the old one, then draw the new one. The putting away process is the opposite of the drawing one. We start with giving the weaponDrawed flag a false value, set the weaponIK aim transform to null, then set the animator parameter to trigger the put away animation. Wait for transition, then wait until the clip is finished playing. Now we successfully put away the old weapon, we then begin to draw the new one. We change the current wepon, swap the anim controller, set the animator parameter to trigger draw weapon anim clip. Wait for transition, then wait until the clip is finished playing. Give weaponDrawed a true value, set the weaponIK aim transform with new current weapon's hotspot. Till here, we equip a new weapon, and switch to it.
![[aiWeapon-codeSnippet03.png]]

Kind of complicated, right? Yes, and we still miss one part. The part where the weapon switches from its mesh socket parent to the holding hand parent, and vice versa. When the character reaches for the weapon, the weapon transform switches parent so that from that point it follows the hand as if the character is really grabbing the weapon. We don't see it in EquipWeapon() because that part is done through animation event. In the draw weapon and put away weapon clips, we add an event at the spot where the hand reaches the weapon, passing a string value as a flag. When we add an event function directly in the inspector of the animation clip, we are defining an event and the event listener function. So, if we type in OnAnimationEvent there in inspector, we can go straight into the implementing of the OnAnimationEvent() method in the script. The process of registering listener function to event is automatically done by Unity.
![[aiWeapon-codeSnippet04.png]]
So we check flag to find out which event and invoke the corresponding logics.
![[aiWeapon-codeSnippet05.png]]
For our case, we use the same flag for draw and put away because there is only one clip, put away clip is the draw clip playing reversely. Therefore, we still need to check if the anim state name is correct for drawing, then we attach the weapon transform to the hand. If the anim state name is for putting away, then we attach the weapon transform to leg or spine based on its weaponID.
![[aiWeapon-codeSnippet06.png]]
Finally, we get to the bottom of this EquipWeapon() method, which is a big one. Now we can move to the next functionality.

How about weapon firing? This is very similar to the process in weapon manager for player. We have a FiringWeapon() method takes in the target transform. Inside, we check if we have a current weapon and if weaponDrawed is true. Only both of them are true, then we are allowed to fire. Maybe we can boil it down to just weaponDrawed, since it seems the flag would only become true in situations where a current weapon is not null. Then, we invoke the weapon's Firing() method. This whole FiringWeapon() method is invoked by the attack player state of state machine. Then, we have the UpdateFiring() method, which just calls the weapon's UpdateBullet() method to simulate bullet. This one is also invoked by the attack player state of state machine. The code is almost the same, it is just we check input to trigger attack for player, and here, the state machine would fire the method calls.

The weapon realod is basically the same thing. The ReloadWeapon() method is also invoked by the attack player state of state machine, but in FixedUpdate() becasue we are performing physics raycast to detect bullet hit. We check for current weapon and weaponDrawed before start the ReloadWeaponAnim() coroutine. The process is simialr to SwitchWeaponAnim() coroutine, we give weaponDrawed a false value, set weaponIK's aim transform to null, set anim parameter to trigger the animation, wait for the transition, wait until the clip is finished playing, then, we set the current weapon's ammoCount equal to its clip size, reset weaponIK's aim transform, reset weaponDrawed to true, and lastly, reset the anim trigger parameter. The reload animation includes four events passing different string values and they have the same listener function OnAnimationEvent(). That's why we see the OnAnimationEvent() method has a switch statement checking for 5 different cases. This part for ai character is exactly the same as the player, using animation event to take care of the magazine instancing and hiding, so that it looks as if the character is really pulling the mag out and refill the ammo.

We also has a PutAwayWeaponAnim() coroutine, but till here, we should know the drill very clearly, just a different clip. But we do provide a wrapper function for it and the SwitchWeaponAnim() coroutine, because we cannot start the coroutine from outside of the class directly, we have to provide an API. In the case of SwitchWeaponAnim(), the method's name is SwitchWeapon(). And the method takes in a WeaponID as parameter to implement some additional logics. That's because the method is invoked when ai character decides one weapon is better than the other at attacking player under certain conditions. And the decision making process is completely irrelevant to the current weapon dictionary content. So ai character might come to a conclusion that hand gun is better now, so it invokes SwitchWeapon(), passing in the weaponID.handgun, not knowing the weapon dictionary only contains machine gun. The SwitchWeapon() method must do some check before it starts the coroutine.
![[aiWeapon-codeSnippet07.png]]

Now, we have only one functionality left to cover, then we are finished with the ai weapon manager class. The last functionality is to drop the weapon, and the method is called DropWeapon(). We can invoke it whenever we see fit. Inside the method, we just set the current weapon transform's parent to null, so it is on its own, then renable the rigidbody and collider components to let the physics take over. This does require the weapon prefab contains those components in the beginning. Otherwise, we add those components on the fly, which is okay, but it is more expensive.

We mention weaponIK several times when examining the ai weapon manager class, and that the one we look into now. Like we said, we can use animation rigging to replace this class, since they are doing the same thing. However, it is valuable to see how to implement a custom aim IK constraint, to understand what's under the hood.

Basically, weaponIK class is obtaining rotation adjustment nessary to make the weapon's transform.forward align to the direction to the target. And apply that adjustment at different levels to affect other parts of the ai character. The whole process is executed in LateUpdate(), only when the aim transform and targer transform are properly set.
![[weaponIK-codeSnippet01.png]]
We have the aim transform as the weapon's hotspot, and target transform as the player's transform, or we can give the player character an empty child object as the aimed target, so we can tune where the ai character is aiming. We obtain the aim transform forward direction by accessing the forward property. Then, we get the target direction by subtracting the target transform position by aim transform direction. Better to normalize it. The Quaternion class has a static method called FromToRotation() taking an original direction plus a desired direction, and returning the angle in Quaternion. That's the angle needed to turn the original direction into the desired direction. Then, we apply it to the joint we want with different weights. No need to apply this to the weapon. Because for example we apply this to the spine joint, the whole upper body would turn including the hands and weapons.
![[weaponIK-codeSnippet02.png]]

That's the basic idea. But we still need to fine tune it like we should give it some angle limit so that the character would not make an impossible rotation to aim, and when the target is too close, we should not aim either, as the target might not be in front of the weapon's hotspot any more.
![[weaponIK-codeSnippet03.png]]

Notice the blendWeight is used for smoothing the transition from character holding weapon without target to rotating to aim at target. Everytime we set and reset the aim transform and target transform for whatever reason, we should put it back to 0f. So that the smooth blending can happen again.![[weaponIK-codeSnippet04.png]]

Okay, till now, we have cover most contents mainly related to the weapon of the ai character.
The technique Unity has for Ai navigation is called NavMesh. We can open the nav mesh window by the top menu ("Window/AI/Navigation"). And we can define parameters of a nav mesh agent, like raidus, height, the max slop and the max step height it can overcome, etc. Once, we finish setting up the parameters, and click bake. Unity would analyize all the static meshes with colliders and generate a walkable area for Ai character, shown with blue overlay in scene view with gizmos on. Area without blue overlay is place where Ai has no clue of and will not get there at its will.

Once we have the nav mesh baked. This information would save with our scene. For our Ai character to utilize this information, we need to add a component called nav mesh agent. With default setting on this component, we can simply give it some Vector3 value as target, and the nav mesh agent component would drive the whole game object on a path to this targeted position. Just like this: `AiCharacter.navMeshAgent.destination = PlayerCharacter.transform.position.`  If the player character is at a place out of the walkable area, the AiCharacter would get to the place where it is the closest walkable position to the player character. Of course, the component has many parameters like max speed, stopping distance, etc. to fine tune the behaviour to suit our need.

One very often need is to tell the character to walk to random positions, and because it can only go to walkable area, we actually need a random walkable position. There is a static method in NavMesh class called `SamplePosition()`.  It takes in a Vector3 position to be used as the origin, and a searching radius in float, it returns a bool to tell if it find any walkable postion within that radius. But just like raycast outputing result to a raycastHit object, the method outputs the result to a NavMeshHit object. And we can retreive the walkable postion from this object's position property. If it finds multiple positions, the nearest one would get outputed. So what we need to do is generate a random direction and possibly times random magnitude, add that to our character's position so that the movement is relative to our character. Pass that into the `SamplePosition()` method to generate random walkable position. If you game has movement along only two axis, then you can use `Random.insideUnitCircle` instead.
![[NavMesh-codeSnippet01.png]]


The locomotion animation of the Ai character can be driven by the property of this nav mesh agent. We can get the nav mesh agent's current speed like this `navAgent.velocity.magnitude`, and apply it to animator parameter, which will be used for driving the blend tree of locomotion. However, remember the animator can apply root motion which is also moving the game object, and both systems are trying to take control of the character would causing the game object to behave incorrectly. Because we have to have nav mesh agent, the answer is to turn off root motion and just let the nav mesh agent to take control. Possible foot sliding would just requires a manual tuning in this case.

If we have any script dedicated to the nav mesh agent, it would be feeding its speed to animator's parameter to drive animation in Update() loop. Other scripts can directly work with the agent component in most cases, there is no need to write an interface. Well, I guess you can and you may if doing so makes sense to you. Let's not be so conclusive.